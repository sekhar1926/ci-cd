apiVersion: v2
name: common-app
description: A common Helm chart for deploying standard microservices in our platform.
type: application

# Version of the chart itself. You can bump this when you make changes to the chart.
version: 0.1.0

# Version of the application this chart deploys. Can be a placeholder.
appVersion: "1.0.0"




# Default values for the common-app chart.
# These will be overridden by the Azure Pipeline for each specific service.

# -- Deployment Configuration --
replicaCount: 1

image:
  repository: placeholder/image # This will be overridden by the pipeline
  pullPolicy: IfNotPresent
  tag: "latest" # This will also be overridden by the pipeline

# -- Service Configuration --
service:
  type: ClusterIP
  port: 8080 # The port your application container listens on

# -- Ingress/Routing Configuration --
# For NGINX VirtualServer resources
virtualServer:
  enabled: true
  host: "placeholder.example.com" # Overridden by pipeline per environment

# -- Secret Management Configuration --
# For the CSI Secret Store Driver
secretProvider:
  enabled: true
  provider: "azure" # The CSI driver you use (e.g., 'azure', 'vault')
  parameters:
    keyvaultName: "placeholder-kv" # Overridden by pipeline per environment
    tenantId: "placeholder-tenant-id" # Your Azure Tenant ID

    # This is the key to flexibility: a list of secrets to be fetched.
    # The application's pipeline will provide the actual list.
    secrets: []
    # Example of how it will be used in the pipeline:
    # secrets:
    # - name: DATABASE-URL       # Name of the secret in Key Vault
    #   alias: DB_URL           # Optional alias for the ENV var name
    # - name: API-KEY

# -- Additional Configuration --
# A place for any non-secret environment variables
extraEnvs: {}
#  Example:
#  extraEnvs:
#    LOGGING_LEVEL: "INFO"
#    SPRING_PROFILES_ACTIVE: "dev"


apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ .Release.Name }}
  template:
    metadata:
      labels:
        app: {{ .Release.Name }}
    spec:
      containers:
        - name: {{ .Release.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: {{ .Values.service.port }}
              protocol: TCP
          # Inject non-secret environment variables
          env:
          {{- range $key, $val := .Values.extraEnvs }}
            - name: {{ $key }}
              value: {{ $val | quote }}
          {{- end }}
          # Inject all secrets from the CSI-created Kubernetes secret
          {{- if and .Values.secretProvider.enabled .Values.secretProvider.parameters.secrets }}
          envFrom:
            - secretRef:
                name: {{ .Release.Name }}-secrets
          {{- end }}
          # Mount the secrets as files (optional but good practice)
          {{- if and .Values.secretProvider.enabled .Values.secretProvider.parameters.secrets }}
          volumeMounts:
            - name: secrets-store-volume
              mountPath: "/mnt/secrets-store"
              readOnly: true
          {{- end }}
      # Define the volume that uses the CSI driver
      {{- if and .Values.secretProvider.enabled .Values.secretProvider.parameters.secrets }}
      volumes:
        - name: secrets-store-volume
          csi:
            driver: secrets-store.csi.k8s.io
            readOnly: true
            volumeAttributes:
              secretProviderClass: {{ .Release.Name }}-spc
      {{- end }}


apiVersion: v1
kind: Service
metadata:
  name: {{ .Release.Name }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app: {{ .Release.Name }}


{{- if and .Values.secretProvider.enabled .Values.secretProvider.parameters.secrets }}
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: {{ .Release.Name }}-spc
spec:
  provider: {{ .Values.secretProvider.provider }}
  # This section tells the CSI driver to create a native Kubernetes secret
  # which our Deployment's 'envFrom' can then use.
  secretObjects:
  - secretName: {{ .Release.Name }}-secrets
    type: Opaque
    data:
    {{- range .Values.secretProvider.parameters.secrets }}
    - objectName: {{ .name }}
      # The key in the k8s secret will be the alias if provided, otherwise the original name.
      # This becomes the environment variable name in the container.
      key: {{ .alias | default .name }}
    {{- end }}
  parameters:
    keyvaultName: {{ .Values.secretProvider.parameters.keyvaultName | quote }}
    tenantId: {{ .Values.secretProvider.parameters.tenantId | quote }}
    # This section tells the driver which objects to fetch from Key Vault
    objects: |
      array:
        {{- range .Values.secretProvider.parameters.secrets }}
        - |
          objectName: {{ .name }}
          objectType: secret
        {{- end }}
{{- end }}


# From the root of your cicd-platform repo
git add charts/
git commit -m "feat: create common-app Helm chart for microservices"
git push

{{- if .Values.virtualServerRoute.enabled }}
apiVersion: k8s.nginx.org/v1
kind: VirtualServerRoute
metadata:
  name: {{ .Release.Name }}-vsr
spec:
  # This section points to the master VirtualServer
  host: {{ .Values.virtualServerRoute.parentVirtualServerName }}.{{ .Values.virtualServerRoute.parentVirtualServerNamespace }}.svc.cluster.local
  subroutes:
  - path: {{ .Values.virtualServerRoute.path }}
    action:
      # This tells NGINX to pass the traffic to our microservice's Service
      pass: {{ .Release.Name }}
{{- end }}

virtualServerRoute:
  enabled: true
  # The namespace where the master VirtualServer lives (e.g., nginx-ingress)
  parentVirtualServerNamespace: "nginx-ingress"
  # The name of the master VirtualServer to attach to
  parentVirtualServerName: "my-company-dev-vs"
  # The path for this specific microservice
  path: "/my-app" # This should be overridden by the pipeline