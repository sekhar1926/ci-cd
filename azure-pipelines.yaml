# This file is the single source of truth for all microservices managed by this platform.
# Add the 'repositoryName' of new services here to make them appear in the release pipeline dropdown.

services:
  - repositoryName: order-service
  - repositoryName: payment-service
  - repositoryName: shipping-service
  - repositoryName: inventory-service
  - repositoryName: user-profile-service
  - repositoryName: manubank-transactions-microservice
  # ... add all your other 100+ service repository names here


# ===================================================================================
# ==           README: Create Single Service Release Pipeline                    ==
# ===================================================================================
#
# PURPOSE:
# This is the standard pipeline for starting a new release for a SINGLE microservice.
# It is designed to be user-friendly and is the recommended best practice for
# one-at-a-time releases.
#
# HOW IT WORKS:
# 1.  **Manual Trigger:** A Release Manager clicks "Run pipeline" in the ADO UI.
# 2.  **Service Dropdown:** The user is presented with a dropdown list of all available
#     microservices. This list is dynamically populated from 'service-manifest.yml'.
# 3.  **Select & Run:** The user selects the service they want to release and clicks "Run".
# 4.  **Automated Release Creation:** The pipeline then executes the standard release
#     logic for that single service: calculates the version and creates the branch.
#
# This provides a simple, foolproof way to initiate releases without needing to
# remember or type repository names.
#
# ===================================================================================

trigger: none
pr: none

# This 'parameters' block is the key to the dynamic dropdown.
parameters:
- name: repositoryName
  displayName: 'Microservice to Release'
  type: string
  default: 'order-service'
  # This loop reads the 'service-manifest.yml' file and populates the dropdown choices.
  values:
  - ${{ each service in fromYAML(readFile('../service-manifest.yml')).services }}:
    - ${{ service.repositoryName }}

pool:
  name: 'MB_DevOps'

# This pipeline now has a single, standard job instead of a complex matrix.
jobs:
- job: CreateReleaseForSingleService
  displayName: 'Create Release for ${{ parameters.repositoryName }}'
  
  steps:
  - task: Bash@3
    displayName: 'Install Tools'
    inputs:
      targetType: 'inline'
      script: |
        echo '{ "name": "create-release-tools", "version": "1.0.0" }' > package.json
        npm install semantic-release @semantic-release/git jq-cli-wrapper
    
  - checkout: git://YourProject/${{ parameters.repositoryName }}@develop
    persistCredentials: true

  - task: Bash@3
    displayName: 'Calculate Next Version for ${{ parameters.repositoryName }}'
    name: CalculateVersion
    workingDirectory: '$(System.DefaultWorkingDirectory)'
    script: |
      # This script is the same as before
      VERSION_JSON=$(npx semantic-release --dry-run -b main)

      if [ -z "$VERSION_JSON" ]; then
        echo "No new changes for ${{ parameters.repositoryName }}. No release will be created."
        echo "##vso[task.setvariable variable=SkipCreation]true"
      else
        NEXT_VERSION=$(echo "$VERSION_JSON" | npx jq -r '.nextRelease.version')
        echo "Next version for ${{ parameters.repositoryName }} is: $NEXT_VERSION"
        echo "##vso[task.setvariable variable=SkipCreation]false"
        echo "##vso[task.setvariable variable=NextVersion;isOutput=true]$NEXT_VERSION"
      fi

  - task: Bash@3
    displayName: 'Create Release Branch for ${{ parameters.repositoryName }}'
    condition: and(succeeded(), eq(variables['CalculateVersion.SkipCreation'], 'false'))
    env:
      GIT_TOKEN: $(System.AccessToken)
    script: |
      set -e
      git config --global user.email "pipeline@azuredevops.com"
      git config --global user.name "Azure DevOps Pipeline"
      
      RELEASE_BRANCH="release/$(CalculateVersion.NextVersion)"
      echo "Creating branch: $RELEASE_BRANCH from develop"
      git checkout -b $RELEASE_BRANCH

      REPO_URL=$(git config --get remote.origin.url)
      AUTH_REPO_URL="https://x-token-auth:$(GIT_TOKEN)@${REPO_URL#https://}"
      git push $AUTH_REPO_URL $RELEASE_BRANCH

      echo "Successfully created and pushed $RELEASE_BRANCH for repository ${{ parameters.repositoryName }}"